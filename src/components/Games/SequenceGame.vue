<template>
  <div class="sequence-game flex column items-center justify-center">
    <div class="timer">‚è≥ {{ t('games.time') }}: <span>{{ timeLeft.toFixed(1) }}</span></div>
    <div class="score">üèÜ {{ t('games.score') }}: <span>{{ score }}/{{ WINNING_STREAK }}</span></div>

    <div v-if="isStarted">
      <div class="cards mb-lg mt-lg">
        <div
          v-for="(card, index) in displayCards"
          :key="index"
          class="card"
          :class="{ 
            'card--memorize': isShowingSequence,
            'card--selected': !isShowingSequence && selectedCards.includes(card),
            'card--success': showSuccess,
            'card--error': showError
          }"
          @click="!isShowingSequence && selectCard(card)"
        >
          {{ card }}
          <span 
            v-if="!isShowingSequence && getSelectionOrder(card)" 
            class="card-order"
          >
            {{ getSelectionOrder(card) }}
          </span>
        </div>
      </div>

      <div class="sequence-status sequence-status--memorize" v-if="isShowingSequence">
        {{ t('games.sequence.memorize') }}
      </div>
      <div class="sequence-status sequence-status--reproduce" v-else>
        {{ t('games.sequence.reproduce') }}
      </div>
    </div>
    <template v-else>
      <div class="sequence-title mt-lg mb-lg">
        {{ t('games.sequence.title') }}
      </div>
      <button 
        class="start-button"
        @click="startGame"
      >
        {{ t('games.sequence.about.btn') }}
      </button>
    </template>

    <SuccessCounter :value="`${score}/${WINNING_STREAK}`" :show="score > 0" />
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';
import { useI18n } from 'vue-i18n';
import SuccessCounter from '@/components/Games/SuccessCounter.vue';

const { t } = useI18n();

const INITIAL_TIME = 5;
const SHOW_SEQUENCE_TIME = 5;
const WINNING_STREAK = 15;

const timeLeft = ref(INITIAL_TIME);
const score = ref(0);
const isStarted = ref(false);
const isShowingSequence = ref(true);
const showSuccess = ref(false);
const showError = ref(false);

const originalSequence = ref<string[]>([]);
const displayCards = ref<string[]>([]);
const selectedCards = ref<string[]>([]);

let timerInterval: ReturnType<typeof setInterval>;
let memorizeTimeout: ReturnType<typeof setTimeout>;

const symbols = [
  '‚≠ê', 'üåà', 'üëÄ', 'üîç', 'üé≤',
  'üé§', 'üíé', 'üíñ', 'üèÜ', 'üí£',
  'A', 'B', 'C', 'D', 'E', 'F',
  '1', '2', '3', '4', '5', '6'
];

function shuffleArray(array: string[]) {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
}

function generateSequence() {
  const shuffled = shuffleArray(symbols);
  return shuffled.slice(0, 6);
}

function startTimer() {
  clearInterval(timerInterval);
  timeLeft.value = INITIAL_TIME;
  timerInterval = setInterval(() => {
    if (timeLeft.value > 0.1) {
      timeLeft.value -= 0.1;
    }
    if (timeLeft.value <= 0.1) {
      clearInterval(timerInterval);
      handleTimeout();
    }
  }, 100);
}

function handleTimeout() {
  showError.value = true;
  score.value = 0;
  setTimeout(() => {
    showError.value = false;
    startNewRound();
  }, 500);
}

function getSelectionOrder(card: string): number | null {
  const index = selectedCards.value.indexOf(card);
  return index === -1 ? null : index + 1;
}

function selectCard(card: string) {
  if (selectedCards.value.includes(card)) {
    // –£–¥–∞–ª—è–µ–º –∫–∞—Ä—Ç—É –∏ –≤—Å–µ –∫–∞—Ä—Ç—ã –ø–æ—Å–ª–µ –Ω–µ—ë
    const index = selectedCards.value.indexOf(card);
    selectedCards.value = selectedCards.value.slice(0, index);
  } else if (selectedCards.value.length < originalSequence.value.length) {
    selectedCards.value.push(card);
  }

  if (selectedCards.value.length === originalSequence.value.length) {
    checkSequence();
  }
}

function checkSequence() {
  const isCorrect = selectedCards.value.every(
    (card, index) => card === originalSequence.value[index]
  );

  if (isCorrect) {
    showSuccess.value = true;
    score.value++;
    setTimeout(() => {
      showSuccess.value = false;
      startNewRound();
    }, 500);
  } else {
    showError.value = true;
    score.value = 0;
    setTimeout(() => {
      showError.value = false;
      startNewRound();
    }, 500);
  }
}

function startNewRound() {
  isShowingSequence.value = true;
  selectedCards.value = [];
  originalSequence.value = generateSequence();
  displayCards.value = [...originalSequence.value];
  timeLeft.value = SHOW_SEQUENCE_TIME;

  // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä –¥–ª—è —Ñ–∞–∑—ã –∑–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
  clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    if (timeLeft.value > 0.1) {
      timeLeft.value -= 0.1;
    }
  }, 100);

  // –ü–æ –∏—Å—Ç–µ—á–µ–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Ñ–∞–∑–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
  clearTimeout(memorizeTimeout);
  memorizeTimeout = setTimeout(() => {
    isShowingSequence.value = false;
    displayCards.value = shuffleArray([...originalSequence.value]);
    startTimer();
  }, SHOW_SEQUENCE_TIME * 1000);
}

function startGame() {
  isStarted.value = true;
  score.value = 0;
  startNewRound();
}

function resetGame() {
  clearInterval(timerInterval);
  clearTimeout(memorizeTimeout);
  isStarted.value = false;
  isShowingSequence.value = true;
  score.value = 0;
  showSuccess.value = false;
  showError.value = false;
  selectedCards.value = [];
  displayCards.value = [];
  timeLeft.value = INITIAL_TIME;
}

onMounted(() => {
  resetGame();
});

onUnmounted(() => {
  clearInterval(timerInterval);
  clearTimeout(memorizeTimeout);
});
</script>

<style scoped lang="scss">
.sequence-game {
  height: calc(100vh - 100px);
}

.sequence-title {
  font-size: 24px;
  text-align: center;
  line-height: 1.4;
  padding: 20px;
  background: var(--card-bg);
  border-radius: 12px;
}

.cards {
  width: 100%;
  display: flex;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
}

.card {
  position: relative;
  width: calc(33% - 8px);
  aspect-ratio: 1/1;
  font-size: 24px;
  cursor: pointer;
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  color: var(--white-color);
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--card-bg);
  transition: all 0.3s ease;

  // –°—Ç–∏–ª—å –¥–ª—è —Ñ–∞–∑—ã –∑–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
  &--memorize {
    background-color: var(--dark-color);
  }

  // –°—Ç–∏–ª—å –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∫–∞—Ä—Ç–æ—á–µ–∫
  &--selected {
    background-color: var(--dark-color);
  }

  &-order {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 20px;
    height: 20px;
    font-size: 24px;
    color: var(--primary);
    font-weight: bold;
  }

  &--success {
    border-color: rgba(75, 181, 67, 1);
    color: rgba(75, 181, 67, 1);
  }

  &--error {
    border-color: rgba(255, 107, 107, 1);
    color: rgba(255, 107, 107, 1);
  }
}

.sequence-status {
  text-align: center;
  font-size: 24px;
  color: var(--primary);
  margin-top: 20px;

  &--reproduce {
    color: rgba(255, 107, 107, 1);
  }
  
  &--memorize {
    color: var(--yellow-color);
  }
}

.timer, .score {
  font-size: 18px;
  margin-top: 10px;
}

.start-button {
  display: block;
  margin: 20px auto;
  padding: 15px 30px;
  font-size: 1.2em;
  background: var(--primary);
  color: var(--dark-color);
  border: none;
  border-radius: 12px;
  cursor: pointer;
  transition: background 0.3s ease;

  &:hover {
    opacity: 0.9;
  }
}
</style> 